# 《通过链表学习Rust》 简体中文版

> 原文链接：[README.md](https://github.com/rust-unofficial/too-many-lists/blob/master/src/README.md)
> <br>
> 翻译基准：[commit c31a062](https://github.com/rust-unofficial/too-many-lists/blob/c31a062c3dcae90e7bf2156d478878ec26c24a3e/src/README.md)

> **注意**：在当前版本中，本书用的是 Rust 2018。如果你的工具链（toolchain）足够
> 新，那么默认状态下，`Cargo.toml` 应该包含 `edition = 2018` 这一行（当然也可能
> 是更大的数字）。用旧的工具链也不是不行，不过这相当于开启了**困难模式**。因为
> 你可能遇到本书中所没有的编译问题。这个过程也是很有趣的！

我经常被问起如何用 Rust 来实现链表，但这其实取决于你的需求是什么。很明显，这个
问题没有简单的答案。所以我准备通过写这本书，一劳永逸地给出一个全面翔实的回答。

在本书中，通过学习 6 种不同的链表实现方式，你将学到基本及进阶的 Rust 编程知识：

* 下列指针类型：`&`，`&mut`，`Box`，`Rc`，`Arc`，`*const`，`*mut`
* 所有权，借用，承袭可变性，内部可变性，`Copy`
* 所有关键字：`struct`，`enum`，`fn`，`pub`，`impl`，`use`，...
* 模式匹配，泛型，析构器
* 如何测试
* 基本的 `unsafe` Rust

的确，在 Rust 中写链表是真的麻烦，以上内容都有所涉及才能写出。

本书所有内容都可在侧边栏中查看（移动端可能崩溃）。方便起见，这里也列出大纲以供
参考：

1. [差的栈实现（基于单向链表）](first.md)
2. [好的栈实现（基于单向链表）](second.md)
3. [可持久化的栈实现（基于单向链表）](third.md)
4. [差的双端队列实现（基于双向链表）](fourth.md)
5. [不安全的队列实现（基于单向链表）](fifth.md)
6. [未完待续：又好又安全的双端队列实现（基于双向链表）](sixth.md)
7. [附加：一些有问题的链表实现](infinity.md)

本书中，我会写出所有输入到终端的命令。也会用到 Cargo 包管理器来开发项目。它不是
写 Rust 所必需的，但相较于直接用 rustc 编译器直接开发，用它还是会**方便得多**。
另外，如果你只是想随便试试，可以用浏览器访问 [play.rust-lang.org][play]，来运行
一些简单的程序。

让我们开始吧！首先创建项目：

```text
$ cargo new --lib lists
     Created library `lists` package
$ cd lists
```

我们准备为每一种实现方式都单独创建一个文件，这样就不会删来删去。

**原汁原味**的 Rust 学习流程应当包括写代码，被编译器怒斥，然后琢磨一堆错误是啥
意思。我会尽量使这个过程多多发生。因为读懂 Rust 编译器的错误提示及相关文档（写
的都很不错）的能力，对于进阶的 Rust 程序员是**非常重要**的。

事实上在写本书的过程中，我遇到的编译错误**远比**展示出来的多。特别是在后续章节
中，我不会面面俱到地写出你们会碰到的编译问题。我只是这场旅途的导游。

本书的节奏还是比较慢的，并且教学风格不会那么严肃。我觉得编程是一件很有意思的的
事！如果你偏好更干货、更正经的教程，那么本书不适合你。

## 公益广告

有一点需要百分百明确：我讨厌链表！当然尽管是很糟糕的数据结构，链表也有一些用武
之地：

* 你有**大量**合并或拆分的操作需求。**大量的**。
* 你想实现无锁并发。
* 你在编写内核态或嵌入式程序。
* 你在用函数式语言。由于语义匮乏及不可变性，相比于其它结构，链表更容易写。
* ……

但在真正写 Rust 程序时，这些情况都是很**罕见**的。99% 的可能是你只需要用到
`Vec`（基于数组的栈）的功能，剩下1%可能会用到 `VecDeque`（基于数组的双端队
列）。由于内存分配频率低、内存额外开销低，并且具有空间局部性以及真正的随机访问
能力，这些数据结构在面对大多数负载时表现的更为优越。

就像字典树（Trie）一样，链表是一种很**特化**、很**小众**的数据结构。我说字典树
小众，很少会有人反驳。因为对于一个普通程序员而言，在整个职业生涯中都几乎不会去
学它。然而链表却好像有着某种奇怪的特殊地位，每个本科生都学过怎么写链表。这在标
准集合库（std::collections）中是唯一的，即 [LinkedList 集合][rust-std-list]，
在 C++ 标准库中则是 [list 容器][cpp-std-list]。

从社区的角度，我们应当反对把链表当作「标准」的数据结构。在特定而非通用情况下，
这个数据结构其实还不错。

有的人读了上面第一段就不读了，然后用接下来的用途列表中的一项作为论据反驳我的观
点。我可以贴出我和他们辩论的网址。但如果你只是想学点 Rust，随时可以跳到
[第一章](first.md)。

### 性能不是一切

无论程序是 I/O 密集型的，或是在偏僻的的角落无足轻重，都不能成为使用链表的理由
你可以用任何数据结构，为什偏要用链表呢？用链式哈希表（linked hash map）！

如果没有性能要求，最自然的选择使用基于数组的结构。

### 如果有了指针，操作就是 O(1) 的

对于合并、分拆、插入、删除操作来说，这是真的！尽管 C++ 之父 Bjarne Stroustrup
[指出][bjarne]，能否用获取指针的时间换取数组复制数据的时间并不重要（其实都很非
常快）。因为在你的工作负载中，除非合并、拆分操作占了大头，否则由于局部性差，代
码更复杂，链表产生的额外开销会抵消理论上的优势。

话又说回来，如果真的有很多合并、拆分操作，用链表还是会提升性能的。

[play]: https://play.rust-lang.org/
[rust-std-list]: https://doc.rust-lang.org/std/collections/struct.LinkedList.html
[cpp-std-list]: http://en.cppreference.com/w/cpp/container/list
[bjarne]: https://www.youtube.com/watch?v=YQs6IC-vgmo
