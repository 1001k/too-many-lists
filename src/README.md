# 《通过链表学习Rust》 简体中文版

> 原文链接：[README.md](https://github.com/rust-unofficial/too-many-lists/blob/master/src/README.md)
> <br>
> 翻译基准：[commit c31a062](https://github.com/rust-unofficial/too-many-lists/blob/c31a062c3dcae90e7bf2156d478878ec26c24a3e/src/README.md)

> **注意**：在当前版本中，本书用的是 Rust 2018。如果你的工具链（toolchain）足够
> 新，那么默认状态下，`Cargo.toml` 应该包含 `edition = 2018` 这一行（当然也可能
> 是更大的数字）。用旧的工具链也不是不行，不过这相当于开启了**困难模式**。因为
> 你可能遇到本书中所没有的编译问题。这个过程也是很有趣的！

我经常被问起如何用 Rust 来实现链表，但这其实取决于你的需求是什么。很明显，这个
问题没有简单的答案。所以我准备通过写这本书，一劳永逸地给出一个全面翔实的回答。

在本书中，通过学习 6 种不同的链表实现方式，你将学到基本及进阶的 Rust 编程知识：

* 下列指针类型：`&`，`&mut`，`Box`，`Rc`，`Arc`，`*const`，`*mut`
* 所有权，借用，承袭可变性，内部可变性，`Copy`
* 所有关键字：`struct`，`enum`，`fn`，`pub`，`impl`，`use`，...
* 模式匹配，泛型，析构器
* 如何测试
* 基本的 `unsafe` Rust

的确，在 Rust 中写链表是真的麻烦，以上内容都有所涉及才能写出。

本书所有内容都可在侧边栏中查看（移动端可能崩溃）。方便起见，这里也列出大纲以供
参考：

1. [差的栈实现（基于单向链表）](first.md)
2. [好的栈实现（基于单向链表）](second.md)
3. [可持久化的栈实现（基于单向链表）](third.md)
4. [差的双端队列实现（基于双向链表）](fourth.md)
5. [不安全的队列实现（基于单向链表）](fifth.md)
6. [未完待续：又好又安全的双端队列实现（基于双向链表）](sixth.md)
7. [附加：一些有问题的链表实现](infinity.md)

本书中，我会写出所有输入到终端的命令。也会用到 Cargo 包管理器来开发项目。它不是
写 Rust 所必需的，但相较于直接用 rustc 编译器直接开发，用它还是会**方便得多**。
另外，如果你只是想随便试试，可以用浏览器访问 [play.rust-lang.org][play]，来运行
一些简单的程序。

让我们开始吧！首先创建项目：

```text
$ cargo new --lib lists
     Created library `lists` package
$ cd lists
```

我们准备为每一种实现方式都单独创建一个文件，这样就不会删来删去。

**原汁原味**的 Rust 学习流程应当包括写代码，被编译器怒斥，然后琢磨一堆错误是啥
意思。我会尽量使这个过程多多发生。因为读懂 Rust 编译器的错误提示及相关文档（写
的都很不错）的能力，对于进阶的 Rust 程序员是**非常重要**的。

事实上在写本书的过程中，我遇到的编译错误**远比**展示出来的多。特别是在后续章节
中，我不会面面俱到地写出你们会碰到的编译问题。我只是这场旅途的导游。

本书的节奏还是比较慢的，并且教学风格不会那么正经[^1]。我觉得编程是一件很有意思
的事，搞起！如果你偏好更干货、更正经的教程，那么本书不适合你。

<!-- markdownlint-disable MD025 -->
# 公益广告
<!-- markdownlint-enable MD025 -->

有一点需要百分百明确：我讨厌链表！当然尽管是很糟糕的数据结构，链表也有一些用武
之地：

* 你有**大量**合并或拆分的操作需求。**大量的**。
* 你想实现无锁并发。
* 你在编写内核态或嵌入式程序。
* 你在用函数式语言。由于语义匮乏及不可变性，相比于其它结构，链表更容易写。
* ······

但在真正写 Rust 程序时，这些情况都是很**罕见**的。99% 的可能是你只需要用到
`Vec`（基于数组的栈）的功能，剩下1%可能会用到 `VecDeque`（基于数组的双端队
列）。由于内存分配频率低、内存额外开销低，并且具有空间局部性以及真正的随机访问
能力，这些数据结构在面对大多数负载时表现的更为优越。

就像字典树（Trie）一样，链表是一种很**特化**、很**小众**的数据结构。我说字典树
小众，很少会有人反驳。因为对于一个普通程序员而言，在整个职业生涯中都几乎不会去
学它。然而链表却好像有着某种奇怪的特殊地位，每个本科生都学过怎么写链表。这在标
准集合库（std::collections）中是唯一的，即 [LinkedList 集合][rust-std-list]，
在 C++ 标准库中则是 [list 容器][cpp-std-list]。

从社区的角度，我们应当**反对**把链表当作「标准」的数据结构。在特定而非通用情况
下，这个数据结构其实还不错。

有的人读了广告第一段就不读了，然后用接下来的用途列表中的一项作为论据反驳我的观
点。我可以贴出我和他们辩论的网址。但如果你只是想学点 Rust，随时可以跳到
[第一章](first.md)。

## 性能不是一切

无论程序是 I/O 密集型的，还是在偏僻的角落里无足轻重，都不能成为使用链表的理由。
你可以用任何数据结构，为什偏要用链表呢？用链式哈希表（linked hash map）！

如果没有性能要求，最自然的选择是使用基于数组的结构。

## 如果有了指针，就可以有 O(1) 的操作

对于合并、拆分、插入、删除操作来说，的确如此！尽管 C++ 之父 Bjarne Stroustrup
[指出][bjarne]，能否用获取指针的时间换取数组复制数据的时间并不重要（其实都很非
常快）。因为在实际任务中，除非合并、拆分操作占了大头，否则由于局部性差，代
码更复杂，链表产生的额外开销会抵消理论上的优势。

**但话又说回来**：如果真的有很多合并、拆分操作，用链表的确会提升性能。

## 我无法接受数组的复杂度是均摊意义上的

现在你到了一个尴尬的境地——大多数人都能接受均摊复杂度。毕竟只有在最坏情况下，数
组的复杂度才会被均摊[^2]。但用数组并不一定会触发最坏情况。如果能预测要存储的元
素数量或其上界，你可以预留对应空间。以我的经验来看，这是**很容易**做到的。
在 Rust 中，所有迭代器都提供 `size_hint` 方法，以应对此类需求。

如果是这样，那么数组栈结构的压入和弹出操作就是真正意义上的 O(1) 复杂度了。而且
会比链表的快很多，因为底层只要干三件事：指针偏移寻址、写入数据、栈的大小加一。
根本涉及不到费时的内存分配操作。

在低延时的方面，情况又如何呢？

**但话又说回来**：如果真的无法预测内存用量，用链表的确可以减少最坏情况下的延迟。

## 链表浪费的内存空间更少

呃，这个话题有点复杂。「典型」的数组容量变更策略是保证最多有一半的空间闲置。这
样说来，确实浪费了好多内存。特别是在 Rust 中，所有容器都不会自动缩减容量
（shrink）。不然如果又来数据填满数组，这步就白干了。所以理论上，数组浪费的空间
是没有上界的。

当然，这只是考虑了极端情况。在最理想情况下，数组结构只有三个指针的额外开销
[^3]，基本可以忽略。

另一方面，链表中每一个元素都无条件地会浪费一定空间。单向链表中，这个空间就是一
个指针占用的空间。同理，双向链表浪费两倍空间。与数组不同，链表的内存浪费率是和
单个元素大小成正比的。如果你储存的是**巨型**结构，那么这方面就可以忽略不计。但
如果储存的结构很小，比如一个字节，那么就会浪费数据 16 倍的内存（32 位平台则是
8 倍）[^4]。

事实上，还要考虑到为了内存对齐而引入的填充字节（padding），这样浪费率就更高了，
达到了 23 倍（32 位平台则是 11 倍）。

上面的讨论还是基于内存分配器工作良好的前提下的，即存在高频率的分配释放操作，并
且假定内存碎片不会造成空间损失。

**但话又说回来**：如果储存的元素真的很大，又无法预测内存用量，并且有合适的内存
分配器，用链表确实可以节省内存空间。

## 我在函数式语言里一直用的是链表

不错！链表在函数式语言中用起来十分优雅，因为执行操作时无需可变性，且可以被递归
定义，甚至得益于惰性求值这个神奇的机制，其长度居然可以是无穷的。

特别是，链表无需任何可变状态就能表示出迭代的语义。每次迭代操作，就是访问递归的
子链表而已。

不过，这里应当说明，Rust 可以对数组进行模式匹配，还可以用[切片][slice]的方式操
作子数组。在某种意义上，这样的操作方式会比函数式的列表更具表达力。比如，你可以
操作只有尾元素的子数组，或是排除了首尾两个元素的中段数组，或是你能想到的更奇怪
的结构。

当然，但你不能用数组切片构成链表。链表结点只能分开存储。

至于惰性求值，我们这有[迭代器][iterator]作为替代，也支持无穷列表。就像函数式列
表那样，它也有 `map`、`filter`、`reverse`、`concatenate` 等操作。不必说，数组切
片也能被转换成迭代器。

**但话又说回来**：如果你被不可变的语义所局限，用链表确实是个好主意。

> **译注**： 脚注都是译者所注，主要补充原文中没有讲明白的细节。

[^1]: 由于译者水平有限，优先考虑准确性及通顺性，许多幽默词句没有翻译出来，望读
者海涵。

[^2]: 指数组结构扩容时，复杂度变为 O(n)。

[^3]: 分别是数组首地址、数组大小、数组容量，都是 `usize` 大小。

[^4]: 应该指的是双向链表。

[play]: https://play.rust-lang.org/
[rust-std-list]: https://doc.rust-lang.org/std/collections/struct.LinkedList.html
[cpp-std-list]: http://en.cppreference.com/w/cpp/container/list
[bjarne]: https://www.youtube.com/watch?v=YQs6IC-vgmo
[slice]: https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html
[iterator]: https://doc.rust-lang.org/std/iter/trait.Iterator.html
